<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Explore - 3D Room</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            background: #87ceeb;
        }

        #info {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            padding: 20px;
            text-align: center;
            color: #2d1810;
            background: rgba(255, 248, 240, 0.9);
            z-index: 100;
            transition: opacity 0.5s;
            border-bottom: 2px solid rgba(139, 90, 43, 0.3);
        }

        #info h1 {
            font-size: 1.5rem;
            margin-bottom: 0.5rem;
            color: #4a3020;
        }

        #info p {
            font-size: 0.9rem;
            opacity: 0.8;
        }

        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 6px;
            height: 6px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 50%;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            box-shadow: 0 0 4px rgba(0,0,0,0.5);
        }

        #tooltip {
            position: fixed;
            top: 60%;
            left: 50%;
            transform: translateX(-50%);
            padding: 12px 24px;
            background: rgba(74, 48, 32, 0.95);
            color: #fff8f0;
            border-radius: 8px;
            font-size: 1rem;
            pointer-events: none;
            z-index: 100;
            opacity: 0;
            transition: opacity 0.3s;
            border: 1px solid rgba(139, 90, 43, 0.5);
        }

        #loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #fff8f0 0%, #f5e6d3 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: #4a3020;
            z-index: 1000;
        }

        #loading h2 {
            margin-bottom: 1rem;
            font-weight: 400;
        }

        .spinner {
            width: 40px;
            height: 40px;
            border: 3px solid rgba(139, 90, 43, 0.3);
            border-top-color: #8b5a2b;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        #progress-container {
            width: 200px;
            height: 6px;
            background: rgba(139, 90, 43, 0.2);
            border-radius: 3px;
            margin-top: 1rem;
            overflow: hidden;
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: #8b5a2b;
            border-radius: 3px;
            transition: width 0.3s ease;
        }

        #progress-text {
            margin-top: 0.5rem;
            font-size: 0.8rem;
            opacity: 0.7;
        }

        #back-link {
            position: fixed;
            bottom: 20px;
            left: 20px;
            color: #4a3020;
            text-decoration: none;
            padding: 10px 20px;
            background: rgba(255, 248, 240, 0.9);
            border-radius: 8px;
            z-index: 100;
            font-size: 0.9rem;
            transition: background 0.3s;
            border: 1px solid rgba(139, 90, 43, 0.3);
        }

        #back-link:hover {
            background: rgba(255, 248, 240, 1);
        }

        canvas {
            display: block;
        }
    </style>
</head>
<body>
    <div id="loading">
        <h2>Entering the study...</h2>
        <div class="spinner"></div>
        <div id="progress-container">
            <div id="progress-bar"></div>
        </div>
        <div id="progress-text">Initializing...</div>
    </div>

    <div id="info">
        <h1>Welcome to My Study</h1>
        <p>Click to look around. WASD to move. Explore the room and interact with objects.</p>
    </div>

    <div id="crosshair"></div>
    <div id="tooltip"></div>

    <a href="index.html" id="back-link">← Back to main site</a>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <!-- Pre-module script to track loading -->
    <script>
        window.updateProgress = function(percent, message) {
            const progressBar = document.getElementById('progress-bar');
            const progressText = document.getElementById('progress-text');
            if (progressBar) progressBar.style.width = percent + '%';
            if (progressText) progressText.textContent = message;
            console.log('[' + percent + '%] ' + message);
        };
        window.updateProgress(5, 'Loading Three.js modules...');

        // Catch module loading errors
        window.addEventListener('error', function(e) {
            console.error('Load error:', e);
            const progressText = document.getElementById('progress-text');
            const progressBar = document.getElementById('progress-bar');
            if (progressText) progressText.textContent = 'Load error: ' + (e.message || 'Module failed to load');
            if (progressBar) progressBar.style.background = '#c00';
        });
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        // ============================================
        // MODEL LOADING SYSTEM
        // ============================================

        const gltfLoader = new GLTFLoader();
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');
        gltfLoader.setDRACOLoader(dracoLoader);

        // Model configuration - maps model names to files and transforms
        // armchair.glb includes: leather armchair, coffee table, floor lamp (all in one)
        // gramophone.glb replaces the old radio
        const MODEL_CONFIG = {
            bookshelf: { file: 'bookshelf.glb', position: [-3.5, 0, -2.5], rotation: [0, Math.PI/2, 0], scale: 1 },
            desk: { file: 'desk.glb', position: [2.5, 0, -2.8], rotation: [0, 0, 0], scale: 1 },
            armchair: { file: 'armchair.glb', position: [-1, 0, 1.5], rotation: [0, Math.PI/4, 0], scale: 1 },
            grandfatherClock: { file: 'grandfather_clock.glb', position: [-3.7, 0, -0.8], rotation: [0, Math.PI/2, 0], scale: 1 },
            gramophone: { file: 'gramophone.glb', position: [2.8, 0, 1.5], rotation: [0, 0, 0], scale: 1 },
            sideTable: { file: 'side_table.glb', position: [-0.3, 0, 1.8], rotation: [0, 0, 0], scale: 1 },
            typewriter: { file: 'typewriter.glb', position: [-3.6, 0.57, 1.2], rotation: [0, Math.PI/2, 0], scale: 1 },
            radio: { file: 'radio.glb', position: [3.85, 1.1, 1.5], rotation: [0, -Math.PI/2, 0], scale: 1 },
            globe: { file: 'globe.glb', position: [3.2, 0, 0.5], rotation: [0, 0, 0], scale: 1 },
            telephone: { file: 'telephone.glb', position: [3.6, 0.58, -2.5], rotation: [0, -Math.PI/3, 0], scale: 1 },
            mirror: { file: 'mirror.glb', position: [3.95, 1.6, 1], rotation: [0, -Math.PI/2, 0], scale: 1 },
            suitcases: { file: 'suitcase.glb', position: [1.5, 0, 3.5], rotation: [0, 0.2, 0], scale: 1 },
        };

        // Track loaded models
        const loadedModels = {};

        // Model loading helper
        async function loadModel(name) {
            const config = MODEL_CONFIG[name];
            if (!config) return null;

            const url = `assets/models/${config.file}`;

            return new Promise((resolve) => {
                gltfLoader.load(
                    url,
                    (gltf) => {
                        const model = gltf.scene;
                        model.position.set(...config.position);
                        model.rotation.set(...config.rotation);
                        if (typeof config.scale === 'number') {
                            model.scale.setScalar(config.scale);
                        } else {
                            model.scale.set(...config.scale);
                        }
                        model.traverse((child) => {
                            if (child.isMesh) {
                                child.castShadow = true;
                                child.receiveShadow = true;
                            }
                        });
                        loadedModels[name] = model;
                        console.log(`✓ Loaded model: ${name}`);
                        resolve(model);
                    },
                    undefined,
                    (error) => {
                        console.log(`○ Model not found: ${name} (using procedural geometry)`);
                        resolve(null);
                    }
                );
            });
        }

        // Load all configured models
        async function loadAllModels() {
            const promises = Object.keys(MODEL_CONFIG).map(name => loadModel(name));
            await Promise.all(promises);
            return loadedModels;
        }

        // Use global updateProgress
        const updateProgress = window.updateProgress;

        updateProgress(10, 'Modules loaded...');

        // Scene setup - warm, sunlit atmosphere
        updateProgress(15, 'Creating scene...');
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd4c4b0); // Warmer, dustier tone
        scene.fog = new THREE.Fog(0xc9b99a, 6, 18); // Closer fog for dusty atmosphere

        const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
        camera.position.set(0.5, 1.6, 2.5); // Moved to avoid collision with side table

        // ============================================
        // PLAYER BODY (visible hands/arms)
        // ============================================

        const playerBodyGroup = new THREE.Group();

        const skinMaterial = new THREE.MeshStandardMaterial({
            color: 0xdeb887, // Skin tone
            roughness: 0.7
        });
        const sleeveMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d3d3d, // Dark sleeve
            roughness: 0.8
        });

        function createArm(isRight) {
            const armGroup = new THREE.Group();
            const side = isRight ? 1 : -1;

            // Forearm (sleeve)
            const forearm = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.045, 0.25, 8),
                sleeveMaterial
            );
            forearm.rotation.x = Math.PI / 2.5;
            forearm.rotation.z = side * 0.3;
            forearm.position.set(side * 0.18, -0.2, -0.35);
            armGroup.add(forearm);

            // Wrist/Hand connection
            const wrist = new THREE.Mesh(
                new THREE.CylinderGeometry(0.025, 0.035, 0.08, 8),
                skinMaterial
            );
            wrist.rotation.x = Math.PI / 2.8;
            wrist.rotation.z = side * 0.25;
            wrist.position.set(side * 0.2, -0.32, -0.45);
            armGroup.add(wrist);

            // Hand (palm)
            const hand = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.02, 0.08),
                skinMaterial
            );
            hand.rotation.x = -0.2;
            hand.rotation.z = side * 0.15;
            hand.position.set(side * 0.21, -0.38, -0.52);
            armGroup.add(hand);

            // Fingers (simplified)
            const fingerGeo = new THREE.CylinderGeometry(0.008, 0.007, 0.04, 6);
            for (let i = 0; i < 4; i++) {
                const finger = new THREE.Mesh(fingerGeo, skinMaterial);
                finger.rotation.x = Math.PI / 2 - 0.1;
                finger.position.set(
                    side * 0.21 + (i - 1.5) * 0.015 * side,
                    -0.39,
                    -0.58 + Math.abs(i - 1.5) * 0.008
                );
                armGroup.add(finger);
            }

            // Thumb
            const thumb = new THREE.Mesh(
                new THREE.CylinderGeometry(0.01, 0.008, 0.035, 6),
                skinMaterial
            );
            thumb.rotation.x = Math.PI / 2.5;
            thumb.rotation.z = side * 0.8;
            thumb.position.set(side * 0.185, -0.37, -0.5);
            armGroup.add(thumb);

            return armGroup;
        }

        playerBodyGroup.add(createArm(false)); // Left arm
        playerBodyGroup.add(createArm(true));  // Right arm
        camera.add(playerBodyGroup);
        scene.add(camera); // Add camera to scene so player body is rendered

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.2;
        document.body.appendChild(renderer.domElement);

        // Controls
        const controls = new PointerLockControls(camera, document.body);
        const info = document.getElementById('info');
        const crosshair = document.getElementById('crosshair');
        const tooltip = document.getElementById('tooltip');
        const loading = document.getElementById('loading');

        document.addEventListener('click', () => {
            if (!controls.isLocked) controls.lock();
        });

        controls.addEventListener('lock', () => {
            info.style.opacity = '0';
            crosshair.style.opacity = '1';
        });

        controls.addEventListener('unlock', () => {
            info.style.opacity = '1';
            crosshair.style.opacity = '0';
            tooltip.style.opacity = '0';
        });

        // Movement
        const velocity = new THREE.Vector3();
        const direction = new THREE.Vector3();
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;

        document.addEventListener('keydown', (e) => {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': moveForward = true; break;
                case 'KeyS': case 'ArrowDown': moveBackward = true; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = true; break;
                case 'KeyD': case 'ArrowRight': moveRight = true; break;
            }
        });

        document.addEventListener('keyup', (e) => {
            switch(e.code) {
                case 'KeyW': case 'ArrowUp': moveForward = false; break;
                case 'KeyS': case 'ArrowDown': moveBackward = false; break;
                case 'KeyA': case 'ArrowLeft': moveLeft = false; break;
                case 'KeyD': case 'ArrowRight': moveRight = false; break;
            }
        });

        // ============================================
        updateProgress(20, 'Setting up lighting...');
        // LIGHTING - Warm sunlight streaming through
        // ============================================

        // Lower ambient for more dramatic shadows (Edith Finch style)
        const ambientLight = new THREE.AmbientLight(0xd4c4b0, 0.4);
        scene.add(ambientLight);

        // Hemisphere light - warm ceiling, cool floor bounce
        const hemiLight = new THREE.HemisphereLight(0xffecd2, 0x5c4033, 0.6);
        scene.add(hemiLight);

        // Main sunlight through window - golden hour feel
        const sunLight = new THREE.DirectionalLight(0xffd27f, 2.5);
        sunLight.position.set(5, 8, -2);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 25;
        sunLight.shadow.camera.left = -10;
        sunLight.shadow.camera.right = 10;
        sunLight.shadow.camera.top = 10;
        sunLight.shadow.camera.bottom = -10;
        sunLight.shadow.bias = -0.0001;
        scene.add(sunLight);

        // Warm fill light from lamp area
        const fillLight = new THREE.PointLight(0xffb347, 1.2, 8);
        fillLight.position.set(-2, 2.5, 0);
        scene.add(fillLight);

        // Strong warm light from window - volumetric feel
        const windowLight = new THREE.SpotLight(0xffefd5, 3.5, 10, Math.PI / 4, 0.5);
        windowLight.position.set(3.8, 2.5, -2);
        windowLight.target.position.set(-1, 0, 1);
        windowLight.castShadow = true;
        scene.add(windowLight);
        scene.add(windowLight.target);

        // Subtle cool rim light from back corners (creates depth)
        const rimLight1 = new THREE.PointLight(0x6b8e9f, 0.5, 6);
        rimLight1.position.set(-3.5, 2.8, -3.5);
        scene.add(rimLight1);

        const rimLight2 = new THREE.PointLight(0x8b9dc3, 0.4, 5);
        rimLight2.position.set(3.5, 2.8, 3.5);
        scene.add(rimLight2);

        // Warm glow from desk lamp area
        const deskLampGlow = new THREE.PointLight(0xffa500, 0.8, 3);
        deskLampGlow.position.set(1.9, 1.2, -2.55);
        scene.add(deskLampGlow);

        // ============================================
        updateProgress(25, 'Creating materials...');
        // MATERIALS - Warm, lived-in textures
        // ============================================

        const wallMaterial = new THREE.MeshStandardMaterial({
            color: 0xf0e4d0,
            roughness: 0.92,
            metalness: 0.0
        });

        const wallpaperMaterial = new THREE.MeshStandardMaterial({
            color: 0xdccbb8,
            roughness: 0.88,
            metalness: 0.0
        });

        const floorMaterial = new THREE.MeshStandardMaterial({
            color: 0x7a5a1e,
            roughness: 0.75,
            metalness: 0.0
        });

        const woodDarkMaterial = new THREE.MeshStandardMaterial({
            color: 0x3d2920,
            roughness: 0.65,
            metalness: 0.0
        });

        const woodLightMaterial = new THREE.MeshStandardMaterial({
            color: 0x785c42,
            roughness: 0.68,
            metalness: 0.0
        });

        const fabricMaterial = new THREE.MeshStandardMaterial({
            color: 0x7a3040,
            roughness: 0.95,
            metalness: 0.0
        });

        const leatherMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a3028,
            roughness: 0.75,
            metalness: 0.05
        });

        const bookColors = [
            new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: 0x2f4f4f, roughness: 0.85 }),
            new THREE.MeshStandardMaterial({ color: 0x3d2920, roughness: 0.75 }),
            new THREE.MeshStandardMaterial({ color: 0x1a3050, roughness: 0.8 }),
            new THREE.MeshStandardMaterial({ color: 0x4a5a2a, roughness: 0.82 }),
            new THREE.MeshStandardMaterial({ color: 0x4a0030, roughness: 0.85 }),
            new THREE.MeshStandardMaterial({ color: 0xc49520, roughness: 0.7 }),
            new THREE.MeshStandardMaterial({ color: 0x252525, roughness: 0.88 })
        ];

        const paperMaterial = new THREE.MeshStandardMaterial({
            color: 0xfff8dc,
            roughness: 0.95
        });

        const plantMaterial = new THREE.MeshStandardMaterial({
            color: 0x228b22,
            roughness: 0.8
        });

        const potMaterial = new THREE.MeshStandardMaterial({
            color: 0xb87333,
            roughness: 0.7
        });

        const brassMaterial = new THREE.MeshStandardMaterial({
            color: 0xb8860b,
            metalness: 0.8,
            roughness: 0.3
        });

        const antiqueGoldMaterial = new THREE.MeshStandardMaterial({
            color: 0xc9a227,
            metalness: 0.6,
            roughness: 0.4
        });

        const velvetMaterial = new THREE.MeshStandardMaterial({
            color: 0x4a1c2a,
            roughness: 0.95
        });

        const crystalMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.7,
            roughness: 0.1,
            metalness: 0.1
        });

        const ivoryMaterial = new THREE.MeshStandardMaterial({
            color: 0xfffff0,
            roughness: 0.6
        });

        const oldPaperMaterial = new THREE.MeshStandardMaterial({
            color: 0xf5deb3,
            roughness: 0.9
        });

        const tarnishedBrassMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b7355,
            metalness: 0.5,
            roughness: 0.6
        });

        // ============================================
        updateProgress(30, 'Building room structure...');
        // ROOM STRUCTURE
        // ============================================

        const roomWidth = 8;
        const roomHeight = 3.2;
        const roomDepth = 8;

        // Floor - warm wooden planks feel
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(roomWidth, roomDepth),
            floorMaterial
        );
        floor.rotation.x = -Math.PI / 2;
        floor.receiveShadow = true;
        scene.add(floor);

        // Ceiling
        const ceiling = new THREE.Mesh(
            new THREE.PlaneGeometry(roomWidth, roomDepth),
            new THREE.MeshStandardMaterial({ color: 0xfff8f0, roughness: 0.95 })
        );
        ceiling.rotation.x = Math.PI / 2;
        ceiling.position.y = roomHeight;
        scene.add(ceiling);

        // Walls
        const createWall = (w, h, pos, rotY = 0, material = wallpaperMaterial) => {
            const wall = new THREE.Mesh(new THREE.PlaneGeometry(w, h), material);
            wall.position.set(pos.x, pos.y, pos.z);
            wall.rotation.y = rotY;
            wall.receiveShadow = true;
            return wall;
        };

        scene.add(createWall(roomWidth, roomHeight, {x: 0, y: roomHeight/2, z: -roomDepth/2}, 0));
        scene.add(createWall(roomWidth, roomHeight, {x: 0, y: roomHeight/2, z: roomDepth/2}, Math.PI));
        scene.add(createWall(roomDepth, roomHeight, {x: -roomWidth/2, y: roomHeight/2, z: 0}, Math.PI/2));
        scene.add(createWall(roomDepth, roomHeight, {x: roomWidth/2, y: roomHeight/2, z: 0}, -Math.PI/2));

        // Baseboard trim
        const baseboardMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.8 });
        const createBaseboard = (length, pos, rotY) => {
            const board = new THREE.Mesh(new THREE.BoxGeometry(length, 0.12, 0.03), baseboardMat);
            board.position.set(pos.x, 0.06, pos.z);
            board.rotation.y = rotY;
            return board;
        };
        scene.add(createBaseboard(roomWidth, {x: 0, z: -roomDepth/2 + 0.015}, 0));
        scene.add(createBaseboard(roomWidth, {x: 0, z: roomDepth/2 - 0.015}, 0));
        scene.add(createBaseboard(roomDepth, {x: -roomWidth/2 + 0.015, z: 0}, Math.PI/2));
        scene.add(createBaseboard(roomDepth, {x: roomWidth/2 - 0.015, z: 0}, Math.PI/2));

        // ============================================
        // WINDOW with light streaming through
        // ============================================

        function createWindow() {
            const group = new THREE.Group();

            // Window frame
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.7 });

            // Outer frame
            const frameOuter = new THREE.Mesh(new THREE.BoxGeometry(1.8, 2.2, 0.1), frameMat);
            group.add(frameOuter);

            // Glass (slightly emissive to simulate sky)
            const glassMat = new THREE.MeshStandardMaterial({
                color: 0x87ceeb,
                transparent: true,
                opacity: 0.3,
                emissive: 0xffeaa7,
                emissiveIntensity: 0.3
            });
            const glass = new THREE.Mesh(new THREE.PlaneGeometry(1.5, 1.9), glassMat);
            glass.position.z = 0.02;
            group.add(glass);

            // Window panes (cross)
            const pane = new THREE.Mesh(new THREE.BoxGeometry(0.05, 1.9, 0.08), frameMat);
            group.add(pane);
            const paneH = new THREE.Mesh(new THREE.BoxGeometry(1.5, 0.05, 0.08), frameMat);
            group.add(paneH);

            // Curtain rod
            const rod = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.02, 2.4, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b4513 })
            );
            rod.rotation.z = Math.PI / 2;
            rod.position.set(0, 1.3, 0.15);
            group.add(rod);

            // Curtains
            const curtainMat = new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.9, side: THREE.DoubleSide });
            const curtainL = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 2.2), curtainMat);
            curtainL.position.set(-0.85, 0, 0.12);
            curtainL.rotation.y = 0.15;
            group.add(curtainL);

            const curtainR = new THREE.Mesh(new THREE.PlaneGeometry(0.6, 2.2), curtainMat);
            curtainR.position.set(0.85, 0, 0.12);
            curtainR.rotation.y = -0.15;
            group.add(curtainR);

            group.position.set(3.95, 1.8, -2);
            group.rotation.y = -Math.PI / 2;
            return group;
        }
        scene.add(createWindow());

        // ============================================
        // FLOATING DUST PARTICLES
        // ============================================

        const dustGeometry = new THREE.BufferGeometry();
        const dustCount = 500;
        const dustPositions = new Float32Array(dustCount * 3);

        for (let i = 0; i < dustCount * 3; i += 3) {
            dustPositions[i] = (Math.random() - 0.5) * roomWidth;
            dustPositions[i + 1] = Math.random() * roomHeight;
            dustPositions[i + 2] = (Math.random() - 0.5) * roomDepth;
        }

        dustGeometry.setAttribute('position', new THREE.BufferAttribute(dustPositions, 3));

        const dustMaterial = new THREE.PointsMaterial({
            color: 0xffeedd,
            size: 0.015,
            transparent: true,
            opacity: 0.6,
            sizeAttenuation: true
        });

        const dustParticles = new THREE.Points(dustGeometry, dustMaterial);
        scene.add(dustParticles);

        // ============================================
        updateProgress(40, 'Creating interactive objects...');
        // INTERACTIVE OBJECTS
        // ============================================

        const interactiveObjects = [];

        // Helper to create book stacks
        function createBookStack(count, baseY, variation = true) {
            const stack = new THREE.Group();
            let y = 0;
            for (let i = 0; i < count; i++) {
                const height = 0.03 + Math.random() * 0.02;
                const width = 0.15 + Math.random() * 0.08;
                const depth = 0.2 + Math.random() * 0.05;
                const book = new THREE.Mesh(
                    new THREE.BoxGeometry(width, height, depth),
                    bookColors[Math.floor(Math.random() * bookColors.length)]
                );
                book.position.y = y + height / 2;
                if (variation) {
                    book.rotation.y = (Math.random() - 0.5) * 0.3;
                    book.position.x = (Math.random() - 0.5) * 0.03;
                }
                book.castShadow = true;
                stack.add(book);
                y += height;
            }
            stack.position.y = baseY;
            return stack;
        }

        // ===== LARGE BOOKSHELF (Notes) =====
        function createBookshelf() {
            const group = new THREE.Group();

            // Main frame
            const frame = new THREE.Mesh(new THREE.BoxGeometry(2, 2.6, 0.4), woodDarkMaterial);
            frame.position.y = 1.3;
            frame.castShadow = true;
            frame.receiveShadow = true;
            group.add(frame);

            // Shelves
            for (let i = 0; i < 5; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.03, 0.38), woodDarkMaterial);
                shelf.position.set(0, 0.2 + i * 0.5, 0.02);
                shelf.receiveShadow = true;
                group.add(shelf);

                // Books on each shelf
                let x = -0.8;
                while (x < 0.75) {
                    const bookW = 0.04 + Math.random() * 0.06;
                    const bookH = 0.25 + Math.random() * 0.15;
                    const book = new THREE.Mesh(
                        new THREE.BoxGeometry(bookW, bookH, 0.18 + Math.random() * 0.08),
                        bookColors[Math.floor(Math.random() * bookColors.length)]
                    );
                    book.position.set(x + bookW/2, 0.22 + i * 0.5 + bookH/2, 0.05);
                    book.rotation.z = (Math.random() - 0.5) * 0.08;
                    book.rotation.y = (Math.random() - 0.5) * 0.1;
                    book.castShadow = true;
                    group.add(book);
                    x += bookW + 0.005;

                    // Occasionally lean some books
                    if (Math.random() > 0.85 && x < 0.5) {
                        const leanBook = new THREE.Mesh(
                            new THREE.BoxGeometry(0.18, 0.04, 0.22),
                            bookColors[Math.floor(Math.random() * bookColors.length)]
                        );
                        leanBook.position.set(x + 0.1, 0.22 + i * 0.5 + 0.02, 0.08);
                        leanBook.rotation.z = Math.PI / 2 - 0.3;
                        group.add(leanBook);
                    }
                }
            }

            // Decorative items on top shelf
            // Small globe
            const globeStand = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.08, 8), woodDarkMaterial);
            globeStand.position.set(-0.6, 2.54, 0.05);
            group.add(globeStand);
            const globe = new THREE.Mesh(
                new THREE.SphereGeometry(0.1, 16, 12),
                new THREE.MeshStandardMaterial({ color: 0x4a7c59, roughness: 0.6 })
            );
            globe.position.set(-0.6, 2.68, 0.05);
            group.add(globe);

            group.position.set(-3.5, 0, -2.5);
            group.rotation.y = Math.PI / 6;

            group.userData = {
                type: 'interactive',
                name: 'Bookshelf',
                action: 'notes/index.html',
                tooltip: 'Browse my study notes'
            };
            return group;
        }
        const bookshelf = createBookshelf();
        scene.add(bookshelf);
        interactiveObjects.push(bookshelf);

        // ===== CLUTTERED DESK (Projects) =====
        function createDesk() {
            const group = new THREE.Group();

            // Desk
            const deskTop = new THREE.Mesh(new THREE.BoxGeometry(1.6, 0.05, 0.8), woodLightMaterial);
            deskTop.position.y = 0.75;
            deskTop.castShadow = true;
            deskTop.receiveShadow = true;
            group.add(deskTop);

            // Legs
            const legGeo = new THREE.BoxGeometry(0.06, 0.73, 0.06);
            [[-0.7, -0.32], [0.7, -0.32], [-0.7, 0.32], [0.7, 0.32]].forEach(([x, z]) => {
                const leg = new THREE.Mesh(legGeo, woodLightMaterial);
                leg.position.set(x, 0.365, z);
                leg.castShadow = true;
                group.add(leg);
            });

            // Drawer
            const drawer = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.15, 0.35), woodDarkMaterial);
            drawer.position.set(0.45, 0.6, 0);
            group.add(drawer);
            const handle = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.02, 0.03),
                new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.6 })
            );
            handle.position.set(0.45, 0.6, 0.19);
            group.add(handle);

            // CLUTTER on desk
            // Stack of papers
            for (let i = 0; i < 8; i++) {
                const paper = new THREE.Mesh(
                    new THREE.BoxGeometry(0.21, 0.002, 0.29),
                    paperMaterial
                );
                paper.position.set(-0.5 + Math.random() * 0.1, 0.78 + i * 0.003, -0.15);
                paper.rotation.y = (Math.random() - 0.5) * 0.2;
                group.add(paper);
            }

            // Open book
            const openBook = new THREE.Group();
            const pageL = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.02, 0.18), paperMaterial);
            pageL.position.x = -0.06;
            pageL.rotation.z = -0.1;
            openBook.add(pageL);
            const pageR = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.02, 0.18), paperMaterial);
            pageR.position.x = 0.06;
            pageR.rotation.z = 0.1;
            openBook.add(pageR);
            const spine = new THREE.Mesh(new THREE.BoxGeometry(0.02, 0.025, 0.18), bookColors[0]);
            openBook.add(spine);
            openBook.position.set(0.1, 0.79, 0.1);
            group.add(openBook);

            // Pen holder with pens
            const holder = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.035, 0.1, 8),
                potMaterial
            );
            holder.position.set(0.55, 0.83, -0.25);
            group.add(holder);
            for (let i = 0; i < 5; i++) {
                const pen = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.005, 0.005, 0.14, 6),
                    new THREE.MeshStandardMaterial({ color: Math.random() > 0.5 ? 0x1a1a1a : 0x8b0000 })
                );
                pen.position.set(0.55 + (Math.random()-0.5)*0.02, 0.92, -0.25 + (Math.random()-0.5)*0.02);
                pen.rotation.x = (Math.random() - 0.5) * 0.3;
                pen.rotation.z = (Math.random() - 0.5) * 0.3;
                group.add(pen);
            }

            // Tea cup
            const cup = new THREE.Mesh(
                new THREE.CylinderGeometry(0.035, 0.03, 0.07, 12),
                new THREE.MeshStandardMaterial({ color: 0xfff8dc, roughness: 0.4 })
            );
            cup.position.set(-0.15, 0.81, 0.28);
            group.add(cup);

            // Small book stack
            const smallStack = createBookStack(4, 0.78);
            smallStack.position.set(0.5, 0, 0.15);
            group.add(smallStack);

            // Desk lamp
            const lampBase = new THREE.Mesh(new THREE.CylinderGeometry(0.06, 0.07, 0.03, 12), woodDarkMaterial);
            lampBase.position.set(-0.6, 0.79, 0.25);
            group.add(lampBase);
            const lampArm = new THREE.Mesh(new THREE.CylinderGeometry(0.01, 0.01, 0.35, 8), new THREE.MeshStandardMaterial({ color: 0xb87333 }));
            lampArm.position.set(-0.6, 0.97, 0.25);
            lampArm.rotation.z = 0.2;
            group.add(lampArm);
            const lampShade = new THREE.Mesh(
                new THREE.ConeGeometry(0.08, 0.1, 12, 1, true),
                new THREE.MeshStandardMaterial({ color: 0x2f4f2f, side: THREE.DoubleSide })
            );
            lampShade.position.set(-0.53, 1.15, 0.25);
            lampShade.rotation.x = Math.PI;
            group.add(lampShade);

            group.position.set(2.5, 0, -2.8);
            group.rotation.y = -Math.PI / 5;

            group.userData = {
                type: 'interactive',
                name: 'Desk',
                action: 'projects.html',
                tooltip: 'View my projects'
            };
            return group;
        }
        const desk = createDesk();
        scene.add(desk);
        interactiveObjects.push(desk);

        // ===== COZY ARMCHAIR (About) =====
        function createArmchair() {
            const group = new THREE.Group();

            // Seat cushion
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.18, 0.65), leatherMaterial);
            seat.position.y = 0.42;
            seat.castShadow = true;
            group.add(seat);

            // Back cushion
            const back = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.65, 0.15), leatherMaterial);
            back.position.set(0, 0.75, -0.27);
            back.rotation.x = 0.1;
            back.castShadow = true;
            group.add(back);

            // Arms
            const armGeo = new THREE.BoxGeometry(0.12, 0.25, 0.55);
            const armL = new THREE.Mesh(armGeo, leatherMaterial);
            armL.position.set(-0.36, 0.55, -0.05);
            group.add(armL);
            const armR = new THREE.Mesh(armGeo, leatherMaterial);
            armR.position.set(0.36, 0.55, -0.05);
            group.add(armR);

            // Wooden frame visible at bottom
            const frame = new THREE.Mesh(new THREE.BoxGeometry(0.75, 0.08, 0.68), woodDarkMaterial);
            frame.position.y = 0.28;
            group.add(frame);

            // Legs
            const legGeo = new THREE.CylinderGeometry(0.03, 0.025, 0.25, 8);
            [[-0.28, 0.22], [0.28, 0.22], [-0.28, -0.22], [0.28, -0.22]].forEach(([x, z]) => {
                const leg = new THREE.Mesh(legGeo, woodDarkMaterial);
                leg.position.set(x, 0.125, z);
                group.add(leg);
            });

            // Throw pillow (smaller, more natural size)
            const pillow = new THREE.Mesh(
                new THREE.BoxGeometry(0.2, 0.08, 0.15),
                new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.9 })
            );
            pillow.position.set(0.1, 0.52, -0.15);
            pillow.rotation.set(0.2, 0.15, 0.05);
            group.add(pillow);

            // Draped blanket (smaller, folded look)
            const blanket = new THREE.Mesh(
                new THREE.PlaneGeometry(0.35, 0.45),
                new THREE.MeshStandardMaterial({ color: 0x8b4557, side: THREE.DoubleSide, roughness: 0.95 })
            );
            blanket.position.set(-0.15, 0.48, 0.05);
            blanket.rotation.set(-0.6, 0.2, 0.1);
            group.add(blanket);

            group.position.set(-1, 0, 1.5);
            group.rotation.y = Math.PI / 4;

            group.userData = {
                type: 'interactive',
                name: 'Reading Chair',
                action: 'about.html',
                tooltip: 'Learn about me'
            };
            return group;
        }
        const armchair = createArmchair();
        scene.add(armchair);
        interactiveObjects.push(armchair);

        // ===== DOOR (Contact) =====
        function createDoor() {
            const group = new THREE.Group();

            // Door frame
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc, roughness: 0.7 });
            const frameTop = new THREE.Mesh(new THREE.BoxGeometry(1.1, 0.1, 0.15), frameMat);
            frameTop.position.y = 2.15;
            group.add(frameTop);
            const frameL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.1, 0.15), frameMat);
            frameL.position.set(-0.5, 1.05, 0);
            group.add(frameL);
            const frameR = new THREE.Mesh(new THREE.BoxGeometry(0.1, 2.1, 0.15), frameMat);
            frameR.position.set(0.5, 1.05, 0);
            group.add(frameR);

            // Door
            const door = new THREE.Mesh(
                new THREE.BoxGeometry(0.9, 2.05, 0.06),
                new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.65 })
            );
            door.position.set(0, 1.025, 0.04);
            door.castShadow = true;
            group.add(door);

            // Door panels (raised detail)
            const panelMat = new THREE.MeshStandardMaterial({ color: 0x5a3a1f, roughness: 0.7 });
            [[0, 0.5], [0, 1.4]].forEach(([x, y]) => {
                const panel = new THREE.Mesh(new THREE.BoxGeometry(0.6, 0.5, 0.02), panelMat);
                panel.position.set(x, y, 0.08);
                group.add(panel);
            });

            // Handle
            const handlePlate = new THREE.Mesh(
                new THREE.BoxGeometry(0.06, 0.15, 0.02),
                new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.7, roughness: 0.3 })
            );
            handlePlate.position.set(0.32, 1.0, 0.1);
            group.add(handlePlate);
            const handleKnob = new THREE.Mesh(
                new THREE.SphereGeometry(0.03, 12, 8),
                new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.7, roughness: 0.3 })
            );
            handleKnob.position.set(0.32, 1.0, 0.14);
            group.add(handleKnob);

            group.position.set(0, 0, 3.92);
            group.rotation.y = Math.PI;

            group.userData = {
                type: 'interactive',
                name: 'Door',
                action: 'contact.html',
                tooltip: 'Get in touch'
            };
            return group;
        }
        const door = createDoor();
        scene.add(door);
        interactiveObjects.push(door);

        // ============================================
        // ADDITIONAL CLUTTER & DECORATION
        // ============================================

        // Large rug
        const rug = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 2.5),
            new THREE.MeshStandardMaterial({ color: 0x8b4557, roughness: 0.95 })
        );
        rug.rotation.x = -Math.PI / 2;
        rug.position.set(0, 0.01, 0);
        scene.add(rug);

        // Smaller decorative rug
        const rug2 = new THREE.Mesh(
            new THREE.CircleGeometry(0.6, 24),
            new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.9 })
        );
        rug2.rotation.x = -Math.PI / 2;
        rug2.position.set(-2.5, 0.012, 1);
        scene.add(rug2);

        // Side table with books
        function createSideTable() {
            const group = new THREE.Group();
            const top = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.04, 16), woodDarkMaterial);
            top.position.y = 0.55;
            top.castShadow = true;
            group.add(top);
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.04, 0.05, 0.53, 8), woodDarkMaterial);
            leg.position.y = 0.265;
            group.add(leg);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.2, 0.22, 0.03, 12), woodDarkMaterial);
            base.position.y = 0.015;
            group.add(base);

            // Stack of books on table
            const stack = createBookStack(5, 0.57);
            stack.position.set(0.05, 0, 0.05);
            group.add(stack);

            // Reading glasses
            const glassesMat = new THREE.MeshStandardMaterial({ color: 0x2f2f2f, metalness: 0.3 });
            const lensL = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), glassesMat);
            lensL.position.set(-0.12, 0.6, -0.08);
            lensL.rotation.y = Math.PI / 2;
            group.add(lensL);
            const lensR = new THREE.Mesh(new THREE.TorusGeometry(0.025, 0.003, 8, 16), glassesMat);
            lensR.position.set(-0.07, 0.6, -0.08);
            lensR.rotation.y = Math.PI / 2;
            group.add(lensR);

            return group;
        }
        const sideTable = createSideTable();
        sideTable.position.set(-0.3, 0, 1.8);
        scene.add(sideTable);

        // Potted plant in corner
        function createPlant() {
            const group = new THREE.Group();
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.12, 0.09, 0.18, 12), potMaterial);
            pot.position.y = 0.09;
            group.add(pot);
            const soil = new THREE.Mesh(
                new THREE.CircleGeometry(0.11, 12),
                new THREE.MeshStandardMaterial({ color: 0x3d2817 })
            );
            soil.rotation.x = -Math.PI / 2;
            soil.position.y = 0.17;
            group.add(soil);

            // Leaves
            for (let i = 0; i < 12; i++) {
                const leaf = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.08, 0.2),
                    new THREE.MeshStandardMaterial({ color: 0x228b22, side: THREE.DoubleSide, roughness: 0.8 })
                );
                const angle = (i / 12) * Math.PI * 2;
                const radius = 0.05;
                leaf.position.set(Math.cos(angle) * radius, 0.3 + Math.random() * 0.15, Math.sin(angle) * radius);
                leaf.rotation.set(
                    -0.5 - Math.random() * 0.5,
                    angle + Math.PI,
                    (Math.random() - 0.5) * 0.3
                );
                group.add(leaf);
            }
            return group;
        }
        const plant1 = createPlant();
        plant1.position.set(3.3, 0, -3.3);
        scene.add(plant1);

        const plant2 = createPlant();
        plant2.position.set(-3.5, 0, 2.5);
        plant2.scale.set(0.8, 0.8, 0.8);
        scene.add(plant2);

        // Picture frames on wall
        function createPictureFrame(w, h) {
            const group = new THREE.Group();
            const frame = new THREE.Mesh(
                new THREE.BoxGeometry(w + 0.08, h + 0.08, 0.03),
                new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.7 })
            );
            group.add(frame);
            const picture = new THREE.Mesh(
                new THREE.PlaneGeometry(w - 0.02, h - 0.02),
                new THREE.MeshStandardMaterial({ color: 0xe8d4c4, roughness: 0.9 })
            );
            picture.position.z = 0.02;
            group.add(picture);
            return group;
        }

        const frame1 = createPictureFrame(0.4, 0.5);
        frame1.position.set(-3.95, 1.7, 0.5);
        frame1.rotation.y = Math.PI / 2;
        scene.add(frame1);

        const frame2 = createPictureFrame(0.35, 0.35);
        frame2.position.set(-3.95, 1.7, 1.2);
        frame2.rotation.y = Math.PI / 2;
        scene.add(frame2);

        const frame3 = createPictureFrame(0.5, 0.4);
        frame3.position.set(-3.95, 1.2, 0.8);
        frame3.rotation.y = Math.PI / 2;
        scene.add(frame3);

        // Floor lamp
        function createFloorLamp() {
            const group = new THREE.Group();
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.18, 0.03, 12), woodDarkMaterial);
            base.position.y = 0.015;
            group.add(base);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.02, 0.02, 1.5, 8), new THREE.MeshStandardMaterial({ color: 0xb87333 }));
            pole.position.y = 0.78;
            group.add(pole);
            const shade = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.25, 0.3, 16, 1, true),
                new THREE.MeshStandardMaterial({ color: 0xfff8dc, side: THREE.DoubleSide, roughness: 0.9 })
            );
            shade.position.y = 1.6;
            group.add(shade);
            return group;
        }
        // Floor lamp is included in armchair.glb model, so we skip the procedural one
        // const floorLamp = createFloorLamp();
        // floorLamp.position.set(2.8, 0, 1.5);
        // scene.add(floorLamp);

        // More scattered books on floor
        const floorBooks1 = createBookStack(3, 0);
        floorBooks1.position.set(-2, 0, -0.5);
        floorBooks1.rotation.y = 0.4;
        scene.add(floorBooks1);

        const floorBooks2 = createBookStack(2, 0);
        floorBooks2.position.set(1.5, 0, 2.5);
        floorBooks2.rotation.y = -0.3;
        scene.add(floorBooks2);

        // ============================================
        updateProgress(60, 'Adding decorative props...');
        // EDITH FINCH-STYLE DECORATIVE PROPS
        // ============================================

        // === GRANDFATHER CLOCK ===
        function createGrandfatherClock() {
            const group = new THREE.Group();

            // Main body - tall cabinet
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x3d2817, roughness: 0.6 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.5, 2.2, 0.35), bodyMat);
            body.position.y = 1.1;
            body.castShadow = true;
            group.add(body);

            // Crown/top decorative piece
            const crown = new THREE.Mesh(new THREE.BoxGeometry(0.55, 0.15, 0.38), bodyMat);
            crown.position.y = 2.25;
            group.add(crown);

            // Pediment (triangular top)
            const pedimentGeo = new THREE.BufferGeometry();
            const pedimentVerts = new Float32Array([
                -0.25, 0, 0.19,  0.25, 0, 0.19,  0, 0.2, 0.19,
                -0.25, 0, -0.19, 0.25, 0, -0.19, 0, 0.2, -0.19,
                -0.25, 0, 0.19, 0, 0.2, 0.19, 0, 0.2, -0.19, -0.25, 0, -0.19,
                0.25, 0, 0.19, 0, 0.2, 0.19, 0, 0.2, -0.19, 0.25, 0, -0.19
            ]);
            pedimentGeo.setAttribute('position', new THREE.BufferAttribute(pedimentVerts, 3));
            pedimentGeo.computeVertexNormals();

            // Simplified crown top
            const crownTop = new THREE.Mesh(new THREE.BoxGeometry(0.45, 0.1, 0.3), bodyMat);
            crownTop.position.y = 2.38;
            group.add(crownTop);

            // Finial on top
            const finial = new THREE.Mesh(
                new THREE.SphereGeometry(0.04, 8, 6),
                brassMaterial
            );
            finial.position.y = 2.48;
            group.add(finial);

            // Clock face area (upper section)
            const faceBox = new THREE.Mesh(
                new THREE.BoxGeometry(0.4, 0.5, 0.02),
                new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.4 })
            );
            faceBox.position.set(0, 1.85, 0.18);
            group.add(faceBox);

            // Clock face circle
            const face = new THREE.Mesh(
                new THREE.CircleGeometry(0.15, 24),
                new THREE.MeshStandardMaterial({ color: 0xfffef5, roughness: 0.3 })
            );
            face.position.set(0, 1.85, 0.2);
            group.add(face);

            // Clock hands
            const hourHand = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.08, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
            );
            hourHand.position.set(0, 1.87, 0.21);
            hourHand.rotation.z = Math.PI / 6;
            group.add(hourHand);

            const minuteHand = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, 0.11, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
            );
            minuteHand.position.set(0, 1.85, 0.21);
            minuteHand.rotation.z = -Math.PI / 3;
            group.add(minuteHand);

            // Pendulum window (glass)
            const pendulumWindow = new THREE.Mesh(
                new THREE.PlaneGeometry(0.25, 0.6),
                new THREE.MeshStandardMaterial({
                    color: 0x87ceeb,
                    transparent: true,
                    opacity: 0.2,
                    roughness: 0.1
                })
            );
            pendulumWindow.position.set(0, 1.15, 0.18);
            group.add(pendulumWindow);

            // Pendulum (grouped for animation)
            const pendulumGroup = new THREE.Group();
            pendulumGroup.position.set(0, 1.35, 0.1);

            const pendulumRod = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.008, 0.45, 8),
                brassMaterial
            );
            pendulumRod.position.y = -0.25;
            pendulumGroup.add(pendulumRod);

            const pendulumDisk = new THREE.Mesh(
                new THREE.CylinderGeometry(0.08, 0.08, 0.02, 16),
                antiqueGoldMaterial
            );
            pendulumDisk.position.y = -0.5;
            pendulumDisk.rotation.x = Math.PI / 2;
            pendulumGroup.add(pendulumDisk);

            group.add(pendulumGroup);
            group.userData.pendulum = pendulumGroup;

            // Base feet
            const footGeo = new THREE.BoxGeometry(0.12, 0.08, 0.1);
            [[-0.18, 0.04, 0.12], [0.18, 0.04, 0.12], [-0.18, 0.04, -0.12], [0.18, 0.04, -0.12]].forEach(pos => {
                const foot = new THREE.Mesh(footGeo, bodyMat);
                foot.position.set(...pos);
                group.add(foot);
            });

            // Decorative molding
            const moldingTop = new THREE.Mesh(
                new THREE.BoxGeometry(0.52, 0.04, 0.36),
                new THREE.MeshStandardMaterial({ color: 0x2d1f14, roughness: 0.5 })
            );
            moldingTop.position.y = 2.15;
            group.add(moldingTop);

            const moldingMid = new THREE.Mesh(
                new THREE.BoxGeometry(0.52, 0.03, 0.36),
                new THREE.MeshStandardMaterial({ color: 0x2d1f14, roughness: 0.5 })
            );
            moldingMid.position.y = 1.55;
            group.add(moldingMid);

            return group;
        }
        const grandfatherClock = createGrandfatherClock();
        grandfatherClock.position.set(-3.7, 0, -0.8);
        grandfatherClock.rotation.y = Math.PI / 2.5;
        scene.add(grandfatherClock);

        // === VINTAGE TYPEWRITER ===
        function createTypewriter() {
            const group = new THREE.Group();
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4 });

            // Main body
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.12, 0.3), bodyMat);
            body.position.y = 0.06;
            group.add(body);

            // Carriage
            const carriage = new THREE.Mesh(new THREE.BoxGeometry(0.38, 0.08, 0.06), bodyMat);
            carriage.position.set(0, 0.16, -0.08);
            group.add(carriage);

            // Paper holder
            const paperHolder = new THREE.Mesh(
                new THREE.BoxGeometry(0.32, 0.15, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x2a2a2a })
            );
            paperHolder.position.set(0, 0.22, -0.12);
            paperHolder.rotation.x = -0.3;
            group.add(paperHolder);

            // Paper in typewriter
            const paper = new THREE.Mesh(
                new THREE.PlaneGeometry(0.22, 0.28),
                oldPaperMaterial
            );
            paper.position.set(0, 0.28, -0.11);
            paper.rotation.x = -0.3;
            group.add(paper);

            // Keyboard area
            const keyboard = new THREE.Mesh(
                new THREE.BoxGeometry(0.28, 0.02, 0.12),
                new THREE.MeshStandardMaterial({ color: 0x333333 })
            );
            keyboard.position.set(0, 0.13, 0.08);
            keyboard.rotation.x = 0.2;
            group.add(keyboard);

            // Individual keys (simplified)
            for (let row = 0; row < 3; row++) {
                for (let col = 0; col < 8; col++) {
                    const key = new THREE.Mesh(
                        new THREE.CylinderGeometry(0.012, 0.012, 0.015, 8),
                        ivoryMaterial
                    );
                    key.position.set(-0.11 + col * 0.03, 0.145 + row * 0.01, 0.12 - row * 0.035);
                    group.add(key);
                }
            }

            // Platen knobs
            const knobGeo = new THREE.CylinderGeometry(0.02, 0.02, 0.03, 8);
            const knobL = new THREE.Mesh(knobGeo, bodyMat);
            knobL.position.set(-0.2, 0.16, -0.08);
            knobL.rotation.z = Math.PI / 2;
            group.add(knobL);
            const knobR = new THREE.Mesh(knobGeo, bodyMat);
            knobR.position.set(0.2, 0.16, -0.08);
            knobR.rotation.z = Math.PI / 2;
            group.add(knobR);

            return group;
        }
        const typewriter = createTypewriter();
        typewriter.position.set(-3.6, 0.57, 1.2);
        typewriter.rotation.y = Math.PI / 2; // Face into room
        // Place on side table against left wall
        const typewriterTable = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.55, 0.4),
            woodDarkMaterial
        );
        typewriterTable.position.set(-3.6, 0.275, 1.2);
        typewriterTable.castShadow = true;
        scene.add(typewriterTable);
        scene.add(typewriter);

        // === OLD RADIO ===
        function createVintageRadio() {
            const group = new THREE.Group();
            const cabinetMat = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.6 });

            // Main cabinet
            const cabinet = new THREE.Mesh(new THREE.BoxGeometry(0.35, 0.25, 0.18), cabinetMat);
            cabinet.position.y = 0.125;
            cabinet.castShadow = true;
            group.add(cabinet);

            // Speaker grille
            const grille = new THREE.Mesh(
                new THREE.PlaneGeometry(0.2, 0.12),
                new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.8 })
            );
            grille.position.set(0, 0.14, 0.091);
            group.add(grille);

            // Dial
            const dial = new THREE.Mesh(
                new THREE.CircleGeometry(0.04, 16),
                new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.3 })
            );
            dial.position.set(-0.1, 0.06, 0.091);
            group.add(dial);

            // Knobs
            const knobGeo = new THREE.CylinderGeometry(0.015, 0.015, 0.02, 8);
            const knob1 = new THREE.Mesh(knobGeo, new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            knob1.position.set(0.08, 0.06, 0.1);
            knob1.rotation.x = Math.PI / 2;
            group.add(knob1);
            const knob2 = new THREE.Mesh(knobGeo, new THREE.MeshStandardMaterial({ color: 0x1a1a1a }));
            knob2.position.set(0.12, 0.06, 0.1);
            knob2.rotation.x = Math.PI / 2;
            group.add(knob2);

            // Decorative top curve
            const topTrim = new THREE.Mesh(
                new THREE.BoxGeometry(0.36, 0.02, 0.19),
                new THREE.MeshStandardMaterial({ color: 0x4a3020, roughness: 0.5 })
            );
            topTrim.position.y = 0.26;
            group.add(topTrim);

            return group;
        }
        const radio = createVintageRadio();
        radio.position.set(3.85, 1.1, 1.5);
        radio.rotation.y = -Math.PI / 2; // Face into room
        // Small shelf for radio - attached to right wall
        const radioShelf = new THREE.Mesh(
            new THREE.BoxGeometry(0.5, 0.03, 0.25),
            woodDarkMaterial
        );
        radioShelf.position.set(3.87, 1.08, 1.5);
        radioShelf.rotation.y = -Math.PI / 2;
        const radioShelfBracket1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, 0.15, 0.2),
            woodDarkMaterial
        );
        radioShelfBracket1.position.set(3.92, 1.0, 1.3);
        const radioShelfBracket2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.03, 0.15, 0.2),
            woodDarkMaterial
        );
        radioShelfBracket2.position.set(3.92, 1.0, 1.7);
        scene.add(radioShelf);
        scene.add(radioShelfBracket1);
        scene.add(radioShelfBracket2);
        scene.add(radio);

        // === VINTAGE CAMERA ON TRIPOD ===
        function createVintageCamera() {
            const group = new THREE.Group();

            // Camera body (box camera style)
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.5 });
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.1, 0.15), bodyMat);
            body.position.y = 0.95;
            group.add(body);

            // Lens
            const lens = new THREE.Mesh(
                new THREE.CylinderGeometry(0.03, 0.035, 0.05, 12),
                new THREE.MeshStandardMaterial({ color: 0x2a2a2a, roughness: 0.3 })
            );
            lens.position.set(0, 0.95, 0.1);
            lens.rotation.x = Math.PI / 2;
            group.add(lens);

            // Lens glass
            const lensGlass = new THREE.Mesh(
                new THREE.CircleGeometry(0.025, 12),
                crystalMaterial
            );
            lensGlass.position.set(0, 0.95, 0.125);
            group.add(lensGlass);

            // Bellows
            const bellows = new THREE.Mesh(
                new THREE.BoxGeometry(0.1, 0.08, 0.04),
                new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.9 })
            );
            bellows.position.set(0, 0.95, 0.065);
            group.add(bellows);

            // Viewfinder
            const viewfinder = new THREE.Mesh(
                new THREE.BoxGeometry(0.04, 0.03, 0.04),
                bodyMat
            );
            viewfinder.position.set(0, 1.02, -0.04);
            group.add(viewfinder);

            // Tripod legs
            const legMat = new THREE.MeshStandardMaterial({ color: 0x4a3728, roughness: 0.6 });
            const legGeo = new THREE.CylinderGeometry(0.01, 0.012, 0.9, 6);
            const angles = [0, 2.1, 4.2];
            angles.forEach(angle => {
                const leg = new THREE.Mesh(legGeo, legMat);
                leg.position.set(Math.sin(angle) * 0.15, 0.45, Math.cos(angle) * 0.15);
                leg.rotation.x = 0.15;
                leg.rotation.z = Math.sin(angle) * 0.15;
                group.add(leg);
            });

            // Tripod head
            const tripodHead = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.03, 0.05, 8),
                legMat
            );
            tripodHead.position.y = 0.88;
            group.add(tripodHead);

            return group;
        }
        const vintageCamera = createVintageCamera();
        vintageCamera.position.set(1.8, 0, -1);
        vintageCamera.rotation.y = Math.PI / 4;
        scene.add(vintageCamera);

        // === CANDELABRA ===
        function createCandelabra() {
            const group = new THREE.Group();

            // Base
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.06, 0.08, 0.03, 12),
                tarnishedBrassMaterial
            );
            base.position.y = 0.015;
            group.add(base);

            // Central stem
            const stem = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.02, 0.25, 8),
                tarnishedBrassMaterial
            );
            stem.position.y = 0.14;
            group.add(stem);

            // Arms and candle holders
            const createCandleArm = (angle, height) => {
                const armGroup = new THREE.Group();

                // Curved arm (simplified as angled cylinder)
                const arm = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.008, 0.008, 0.1, 6),
                    tarnishedBrassMaterial
                );
                arm.rotation.z = Math.PI / 3;
                arm.position.set(0.04, 0, 0);
                armGroup.add(arm);

                // Candle cup
                const cup = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.02, 0.015, 0.02, 8),
                    tarnishedBrassMaterial
                );
                cup.position.set(0.08, 0.04, 0);
                armGroup.add(cup);

                // Candle
                const candle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.012, 0.015, 0.12, 8),
                    ivoryMaterial
                );
                candle.position.set(0.08, 0.11, 0);
                armGroup.add(candle);

                // Dripping wax effect
                const drip = new THREE.Mesh(
                    new THREE.SphereGeometry(0.015, 6, 4),
                    ivoryMaterial
                );
                drip.position.set(0.08, 0.05, 0);
                drip.scale.y = 1.5;
                armGroup.add(drip);

                armGroup.position.y = height;
                armGroup.rotation.y = angle;
                return armGroup;
            };

            group.add(createCandleArm(0, 0.22));
            group.add(createCandleArm(Math.PI * 2/3, 0.22));
            group.add(createCandleArm(Math.PI * 4/3, 0.22));

            // Central candle holder
            const centerCup = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.015, 0.02, 8),
                tarnishedBrassMaterial
            );
            centerCup.position.y = 0.28;
            group.add(centerCup);

            const centerCandle = new THREE.Mesh(
                new THREE.CylinderGeometry(0.012, 0.015, 0.15, 8),
                ivoryMaterial
            );
            centerCandle.position.y = 0.36;
            group.add(centerCandle);

            return group;
        }
        const candelabra = createCandelabra();
        candelabra.position.set(-0.3, 0.58, 1.8);
        scene.add(candelabra);

        // === MUSIC BOX ===
        function createMusicBox() {
            const group = new THREE.Group();

            // Box body
            const boxMat = new THREE.MeshStandardMaterial({ color: 0x6b4423, roughness: 0.5 });
            const box = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.06, 0.1), boxMat);
            box.position.y = 0.03;
            group.add(box);

            // Lid (slightly open)
            const lid = new THREE.Mesh(new THREE.BoxGeometry(0.12, 0.01, 0.1), boxMat);
            lid.position.set(0, 0.065, -0.045);
            lid.rotation.x = -0.4;
            group.add(lid);

            // Interior velvet
            const velvet = new THREE.Mesh(
                new THREE.PlaneGeometry(0.1, 0.08),
                velvetMaterial
            );
            velvet.position.set(0, 0.06, 0);
            velvet.rotation.x = -Math.PI / 2;
            group.add(velvet);

            // Small dancing figure
            const figure = new THREE.Mesh(
                new THREE.CylinderGeometry(0.008, 0.005, 0.04, 8),
                new THREE.MeshStandardMaterial({ color: 0xffe4c4 })
            );
            figure.position.set(0, 0.08, 0.01);
            group.add(figure);

            // Decorative inlay
            const inlay = new THREE.Mesh(
                new THREE.PlaneGeometry(0.08, 0.06),
                new THREE.MeshStandardMaterial({ color: 0xdaa520, roughness: 0.7 })
            );
            inlay.position.set(0, 0.061, 0);
            inlay.rotation.x = -Math.PI / 2;
            group.add(inlay);

            return group;
        }
        const musicBox = createMusicBox();
        musicBox.position.set(-0.15, 0.58, 1.85);
        musicBox.rotation.y = 0.3;
        scene.add(musicBox);

        // === POCKET WATCH ===
        function createPocketWatch() {
            const group = new THREE.Group();

            // Watch case
            const caseOuter = new THREE.Mesh(
                new THREE.CylinderGeometry(0.025, 0.025, 0.008, 16),
                antiqueGoldMaterial
            );
            caseOuter.rotation.x = Math.PI / 2;
            group.add(caseOuter);

            // Watch face
            const face = new THREE.Mesh(
                new THREE.CircleGeometry(0.022, 16),
                new THREE.MeshStandardMaterial({ color: 0xfffff5, roughness: 0.3 })
            );
            face.position.z = 0.005;
            group.add(face);

            // Watch chain
            const chain = new THREE.Mesh(
                new THREE.TorusGeometry(0.04, 0.003, 4, 20, Math.PI),
                antiqueGoldMaterial
            );
            chain.position.set(0.04, 0, 0);
            chain.rotation.y = Math.PI / 2;
            group.add(chain);

            // Crown
            const crown = new THREE.Mesh(
                new THREE.CylinderGeometry(0.005, 0.005, 0.01, 8),
                antiqueGoldMaterial
            );
            crown.position.set(0, 0.028, 0);
            group.add(crown);

            return group;
        }
        const pocketWatch = createPocketWatch();
        pocketWatch.position.set(-0.25, 0.585, 1.75);
        pocketWatch.rotation.x = -Math.PI / 2;
        pocketWatch.rotation.z = 0.5;
        scene.add(pocketWatch);

        // === OLD LETTERS AND DOCUMENTS ===
        function createLetterPile() {
            const group = new THREE.Group();

            for (let i = 0; i < 6; i++) {
                const letter = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.12, 0.08),
                    oldPaperMaterial
                );
                letter.position.set(
                    (Math.random() - 0.5) * 0.05,
                    0.002 + i * 0.003,
                    (Math.random() - 0.5) * 0.05
                );
                letter.rotation.x = -Math.PI / 2;
                letter.rotation.z = (Math.random() - 0.5) * 0.4;
                group.add(letter);
            }

            // Envelope
            const envelope = new THREE.Mesh(
                new THREE.BoxGeometry(0.14, 0.003, 0.09),
                new THREE.MeshStandardMaterial({ color: 0xf5deb3, roughness: 0.8 })
            );
            envelope.position.set(0.05, 0.02, -0.02);
            envelope.rotation.y = -0.2;
            group.add(envelope);

            // Wax seal on envelope
            const seal = new THREE.Mesh(
                new THREE.CylinderGeometry(0.012, 0.012, 0.004, 8),
                new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.6 })
            );
            seal.position.set(0.05, 0.024, -0.02);
            group.add(seal);

            return group;
        }
        const letters = createLetterPile();
        letters.position.set(2.3, 0.78, -2.6); // On the desk
        letters.rotation.y = -Math.PI / 5;
        scene.add(letters);

        // === VINTAGE TELEPHONE ===
        function createVintageTelephone() {
            const group = new THREE.Group();
            const phoneMat = new THREE.MeshStandardMaterial({ color: 0x1a1a1a, roughness: 0.4 });

            // Base
            const base = new THREE.Mesh(
                new THREE.BoxGeometry(0.15, 0.05, 0.12),
                phoneMat
            );
            base.position.y = 0.025;
            group.add(base);

            // Dial area
            const dialBase = new THREE.Mesh(
                new THREE.CylinderGeometry(0.04, 0.045, 0.02, 12),
                phoneMat
            );
            dialBase.position.set(0, 0.06, 0);
            group.add(dialBase);

            // Dial
            const dial = new THREE.Mesh(
                new THREE.CircleGeometry(0.035, 16),
                new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.4 })
            );
            dial.position.set(0, 0.071, 0);
            dial.rotation.x = -Math.PI / 2;
            group.add(dial);

            // Handset cradle
            const cradle = new THREE.Mesh(
                new THREE.BoxGeometry(0.14, 0.02, 0.03),
                phoneMat
            );
            cradle.position.set(0, 0.08, 0);
            group.add(cradle);

            // Handset
            const handsetBody = new THREE.Mesh(
                new THREE.CylinderGeometry(0.015, 0.015, 0.14, 8),
                phoneMat
            );
            handsetBody.position.set(0, 0.1, 0);
            handsetBody.rotation.z = Math.PI / 2;
            group.add(handsetBody);

            // Earpiece
            const earpiece = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 6),
                phoneMat
            );
            earpiece.position.set(-0.07, 0.1, 0);
            earpiece.scale.set(1, 0.7, 1);
            group.add(earpiece);

            // Mouthpiece
            const mouthpiece = new THREE.Mesh(
                new THREE.SphereGeometry(0.025, 8, 6),
                phoneMat
            );
            mouthpiece.position.set(0.07, 0.1, 0);
            mouthpiece.scale.set(1, 0.7, 1);
            group.add(mouthpiece);

            return group;
        }
        const telephone = createVintageTelephone();
        telephone.position.set(3.6, 0.58, -2.5);
        telephone.rotation.y = -Math.PI / 3;
        // Small telephone table near right wall
        const phoneTable = new THREE.Mesh(
            new THREE.CylinderGeometry(0.18, 0.15, 0.56, 8),
            woodDarkMaterial
        );
        phoneTable.position.set(3.6, 0.28, -2.5);
        scene.add(phoneTable);
        scene.add(telephone);

        // === OLD TOYS - WOODEN HORSE ===
        function createWoodenHorse() {
            const group = new THREE.Group();
            const horseMat = new THREE.MeshStandardMaterial({ color: 0xc4a35a, roughness: 0.7 });

            // Body
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.08, 0.04, 0.03),
                horseMat
            );
            body.position.y = 0.06;
            group.add(body);

            // Head
            const head = new THREE.Mesh(
                new THREE.BoxGeometry(0.025, 0.04, 0.02),
                horseMat
            );
            head.position.set(0.045, 0.085, 0);
            head.rotation.z = 0.3;
            group.add(head);

            // Legs
            const legGeo = new THREE.BoxGeometry(0.01, 0.04, 0.01);
            [[-0.03, 0.02, 0.008], [0.03, 0.02, 0.008], [-0.03, 0.02, -0.008], [0.03, 0.02, -0.008]].forEach(pos => {
                const leg = new THREE.Mesh(legGeo, horseMat);
                leg.position.set(...pos);
                group.add(leg);
            });

            // Rockers
            const rockerMat = new THREE.MeshStandardMaterial({ color: 0x8b4513, roughness: 0.6 });
            const rocker = new THREE.Mesh(
                new THREE.TorusGeometry(0.05, 0.005, 4, 12, Math.PI),
                rockerMat
            );
            rocker.position.set(0, 0.01, 0.012);
            rocker.rotation.x = Math.PI / 2;
            rocker.rotation.z = Math.PI;
            group.add(rocker);

            const rocker2 = rocker.clone();
            rocker2.position.z = -0.012;
            group.add(rocker2);

            return group;
        }
        const woodenHorse = createWoodenHorse();
        woodenHorse.position.set(-3.2, 0, 3.5); // Near back-left corner
        woodenHorse.rotation.y = -0.6;
        scene.add(woodenHorse);

        // === VINTAGE GLOBE (larger, floor standing) ===
        function createFloorGlobe() {
            const group = new THREE.Group();

            // Base
            const base = new THREE.Mesh(
                new THREE.CylinderGeometry(0.15, 0.18, 0.03, 12),
                woodDarkMaterial
            );
            base.position.y = 0.015;
            group.add(base);

            // Stand
            const stand = new THREE.Mesh(
                new THREE.CylinderGeometry(0.02, 0.025, 0.7, 8),
                woodDarkMaterial
            );
            stand.position.y = 0.38;
            group.add(stand);

            // Globe ring (meridian)
            const ring = new THREE.Mesh(
                new THREE.TorusGeometry(0.18, 0.01, 8, 32),
                tarnishedBrassMaterial
            );
            ring.position.y = 0.8;
            ring.rotation.z = 0.4;
            group.add(ring);

            // Globe sphere
            const globe = new THREE.Mesh(
                new THREE.SphereGeometry(0.16, 24, 16),
                new THREE.MeshStandardMaterial({
                    color: 0x4a7c59,
                    roughness: 0.6
                })
            );
            globe.position.y = 0.8;
            group.add(globe);

            // Continents hint (simple bands)
            const land = new THREE.Mesh(
                new THREE.SphereGeometry(0.161, 24, 16, 0, Math.PI * 2, 0.4, 0.8),
                new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.7 })
            );
            land.position.y = 0.8;
            land.rotation.y = 1.2;
            group.add(land);

            return group;
        }
        const floorGlobe = createFloorGlobe();
        floorGlobe.position.set(3.2, 0, 0.5);
        scene.add(floorGlobe);

        // === STACKED SUITCASES ===
        function createSuitcaseStack() {
            const group = new THREE.Group();

            const createSuitcase = (w, h, d, color, y) => {
                const mat = new THREE.MeshStandardMaterial({ color, roughness: 0.7 });
                const suitcase = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
                suitcase.position.y = y;
                suitcase.castShadow = true;

                // Handle
                const handle = new THREE.Mesh(
                    new THREE.TorusGeometry(0.03, 0.008, 4, 8, Math.PI),
                    new THREE.MeshStandardMaterial({ color: 0x4a3728 })
                );
                handle.position.set(0, y + h/2 + 0.02, 0);
                handle.rotation.x = -Math.PI / 2;
                group.add(handle);

                // Latches
                const latchGeo = new THREE.BoxGeometry(0.025, 0.015, 0.01);
                const latchMat = new THREE.MeshStandardMaterial({ color: 0xb87333, metalness: 0.5 });
                const latch1 = new THREE.Mesh(latchGeo, latchMat);
                latch1.position.set(-0.08, y, d/2 + 0.005);
                group.add(latch1);
                const latch2 = new THREE.Mesh(latchGeo, latchMat);
                latch2.position.set(0.08, y, d/2 + 0.005);
                group.add(latch2);

                return suitcase;
            };

            group.add(createSuitcase(0.5, 0.15, 0.35, 0x5c4033, 0.075));
            group.add(createSuitcase(0.45, 0.12, 0.32, 0x8b4513, 0.21));
            group.add(createSuitcase(0.35, 0.1, 0.28, 0x654321, 0.32));

            return group;
        }
        const suitcases = createSuitcaseStack();
        suitcases.position.set(1.5, 0, 3.5); // Near the door, as if just arrived
        suitcases.rotation.y = 0.2;
        scene.add(suitcases);

        // === ORNATE MIRROR ===
        function createOrnateMirror() {
            const group = new THREE.Group();

            // Outer frame (ornate oval)
            const frameOuter = new THREE.Mesh(
                new THREE.TorusGeometry(0.35, 0.04, 8, 32),
                antiqueGoldMaterial
            );
            group.add(frameOuter);

            // Mirror surface
            const mirror = new THREE.Mesh(
                new THREE.CircleGeometry(0.32, 32),
                new THREE.MeshStandardMaterial({
                    color: 0xc0c0c0,
                    metalness: 0.9,
                    roughness: 0.1
                })
            );
            mirror.position.z = 0.01;
            group.add(mirror);

            // Top ornament
            const ornament = new THREE.Mesh(
                new THREE.SphereGeometry(0.05, 8, 6),
                antiqueGoldMaterial
            );
            ornament.position.y = 0.38;
            ornament.scale.set(1.5, 1, 0.5);
            group.add(ornament);

            return group;
        }
        const mirror = createOrnateMirror();
        mirror.position.set(3.95, 1.6, 1);
        mirror.rotation.y = -Math.PI / 2;
        scene.add(mirror);

        // === SCATTERED PHOTOGRAPHS ===
        function createScatteredPhotos() {
            const group = new THREE.Group();
            const sepia = new THREE.MeshStandardMaterial({ color: 0xd4a574, roughness: 0.8 });

            for (let i = 0; i < 5; i++) {
                // Photo
                const photo = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.08, 0.06),
                    sepia
                );
                photo.position.set(
                    (Math.random() - 0.5) * 0.15,
                    0.002 + i * 0.002,
                    (Math.random() - 0.5) * 0.1
                );
                photo.rotation.x = -Math.PI / 2;
                photo.rotation.z = (Math.random() - 0.5) * 0.8;
                group.add(photo);

                // White border
                const border = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.09, 0.07),
                    new THREE.MeshStandardMaterial({ color: 0xfffff0, roughness: 0.9 })
                );
                border.position.copy(photo.position);
                border.position.y -= 0.001;
                border.rotation.copy(photo.rotation);
                group.add(border);
            }

            return group;
        }
        const photos = createScatteredPhotos();
        photos.position.set(-0.35, 0.57, 1.75); // On the side table
        scene.add(photos);

        // === ANTIQUE INK BOTTLE ===
        const inkBottle = new THREE.Group();
        const bottleBody = new THREE.Mesh(
            new THREE.CylinderGeometry(0.025, 0.03, 0.06, 8),
            new THREE.MeshStandardMaterial({
                color: 0x1a1a40,
                transparent: true,
                opacity: 0.8,
                roughness: 0.2
            })
        );
        bottleBody.position.y = 0.03;
        inkBottle.add(bottleBody);
        const bottleNeck = new THREE.Mesh(
            new THREE.CylinderGeometry(0.012, 0.015, 0.02, 8),
            new THREE.MeshStandardMaterial({ color: 0x1a1a40, transparent: true, opacity: 0.8 })
        );
        bottleNeck.position.y = 0.07;
        inkBottle.add(bottleNeck);
        const bottleCork = new THREE.Mesh(
            new THREE.CylinderGeometry(0.01, 0.012, 0.015, 6),
            new THREE.MeshStandardMaterial({ color: 0x8b7355, roughness: 0.9 })
        );
        bottleCork.position.y = 0.085;
        inkBottle.add(bottleCork);
        inkBottle.position.set(2.7, 0.78, -2.5); // On the desk
        scene.add(inkBottle);

        // === QUILL PEN ===
        const quill = new THREE.Group();
        const feather = new THREE.Mesh(
            new THREE.PlaneGeometry(0.02, 0.15),
            new THREE.MeshStandardMaterial({ color: 0xf5f5f5, side: THREE.DoubleSide })
        );
        feather.rotation.x = -0.1;
        feather.position.y = 0.075;
        quill.add(feather);
        const quillTip = new THREE.Mesh(
            new THREE.ConeGeometry(0.003, 0.03, 4),
            new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
        );
        quillTip.position.y = -0.015;
        quillTip.rotation.x = Math.PI;
        quill.add(quillTip);
        quill.position.set(2.65, 0.79, -2.55); // On the desk near ink bottle
        quill.rotation.z = -0.3;
        quill.rotation.x = -Math.PI / 2;
        scene.add(quill);

        // === MORE WALL DECORATIONS ===
        // Coat hooks with items
        const coatHook = new THREE.Mesh(
            new THREE.TorusGeometry(0.03, 0.008, 6, 8, Math.PI),
            tarnishedBrassMaterial
        );
        coatHook.position.set(-3.95, 1.4, 2.5);
        coatHook.rotation.y = Math.PI / 2;
        coatHook.rotation.z = -Math.PI / 4;
        scene.add(coatHook);

        // Hat on hook
        const hatCrown = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.1, 0.1, 12),
            new THREE.MeshStandardMaterial({ color: 0x2f2f2f, roughness: 0.8 })
        );
        hatCrown.position.set(-3.88, 1.32, 2.5); // Lowered to hang on hook
        hatCrown.rotation.z = 0.3;
        scene.add(hatCrown);
        const hatBrim = new THREE.Mesh(
            new THREE.CylinderGeometry(0.14, 0.14, 0.015, 16),
            new THREE.MeshStandardMaterial({ color: 0x2f2f2f, roughness: 0.8 })
        );
        hatBrim.position.set(-3.88, 1.27, 2.5); // Lowered to hang on hook
        hatBrim.rotation.z = 0.3;
        scene.add(hatBrim);

        // === ADDITIONAL BOOK STACKS FOR CLUTTER ===
        const extraBooks1 = createBookStack(6, 0);
        extraBooks1.position.set(0.8, 0, 3);
        extraBooks1.rotation.y = 0.7;
        scene.add(extraBooks1);

        const extraBooks2 = createBookStack(4, 0);
        extraBooks2.position.set(-1.2, 0, 2.8);
        scene.add(extraBooks2);

        const extraBooks3 = createBookStack(2, 0);
        extraBooks3.position.set(2, 0, 0.5);
        extraBooks3.rotation.y = -0.5;
        scene.add(extraBooks3);

        // === MORE PICTURE FRAMES ON BACK WALL ===
        const frame4 = createPictureFrame(0.5, 0.4);
        frame4.position.set(-1.5, 1.8, 3.95);
        frame4.rotation.y = Math.PI;
        scene.add(frame4);

        const frame5 = createPictureFrame(0.3, 0.4);
        frame5.position.set(-0.8, 1.6, 3.95);
        frame5.rotation.y = Math.PI;
        scene.add(frame5);

        const frame6 = createPictureFrame(0.45, 0.35);
        frame6.position.set(1.5, 1.7, 3.95);
        frame6.rotation.y = Math.PI;
        scene.add(frame6);

        // === WALL CLOCK (smaller) ===
        function createWallClock() {
            const group = new THREE.Group();

            // Clock body
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.2, 0.2, 0.04, 24),
                woodDarkMaterial
            );
            body.rotation.x = Math.PI / 2;
            group.add(body);

            // Clock face
            const face = new THREE.Mesh(
                new THREE.CircleGeometry(0.17, 24),
                new THREE.MeshStandardMaterial({ color: 0xfffff5, roughness: 0.3 })
            );
            face.position.z = 0.021;
            group.add(face);

            // Hour markers
            for (let i = 0; i < 12; i++) {
                const angle = (i / 12) * Math.PI * 2;
                const marker = new THREE.Mesh(
                    new THREE.BoxGeometry(0.01, 0.02, 0.01),
                    new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
                );
                marker.position.set(
                    Math.sin(angle) * 0.14,
                    Math.cos(angle) * 0.14,
                    0.022
                );
                marker.rotation.z = -angle;
                group.add(marker);
            }

            // Hands
            const hourHand = new THREE.Mesh(
                new THREE.BoxGeometry(0.015, 0.08, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
            );
            hourHand.position.set(0.02, 0.02, 0.025);
            hourHand.rotation.z = -Math.PI / 4;
            group.add(hourHand);

            const minuteHand = new THREE.Mesh(
                new THREE.BoxGeometry(0.01, 0.12, 0.01),
                new THREE.MeshStandardMaterial({ color: 0x1a1a1a })
            );
            minuteHand.position.set(-0.04, 0.03, 0.025);
            minuteHand.rotation.z = Math.PI / 3;
            group.add(minuteHand);

            // Center cap
            const cap = new THREE.Mesh(
                new THREE.SphereGeometry(0.015, 8, 6),
                brassMaterial
            );
            cap.position.z = 0.025;
            group.add(cap);

            return group;
        }
        const wallClock = createWallClock();
        wallClock.position.set(2.5, 2.2, 3.95); // Moved away from door
        wallClock.rotation.y = Math.PI;
        scene.add(wallClock);

        // === SMALL SHELF WITH KNICKKNACKS ===
        const smallShelf = new THREE.Mesh(
            new THREE.BoxGeometry(0.6, 0.02, 0.12),
            woodDarkMaterial
        );
        smallShelf.position.set(3.95, 1.3, -0.5);
        smallShelf.rotation.y = -Math.PI / 2;
        scene.add(smallShelf);

        // Shelf brackets
        const bracket1 = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, 0.1, 0.1),
            woodDarkMaterial
        );
        bracket1.position.set(3.93, 1.25, -0.25);
        scene.add(bracket1);
        const bracket2 = new THREE.Mesh(
            new THREE.BoxGeometry(0.02, 0.1, 0.1),
            woodDarkMaterial
        );
        bracket2.position.set(3.93, 1.25, -0.75);
        scene.add(bracket2);

        // Small items on shelf
        // Tiny vase
        const tinyVase = new THREE.Mesh(
            new THREE.CylinderGeometry(0.02, 0.025, 0.06, 8),
            new THREE.MeshStandardMaterial({ color: 0x4682b4, roughness: 0.4 })
        );
        tinyVase.position.set(3.9, 1.34, -0.4);
        scene.add(tinyVase);

        // Small figurine
        const figurine = new THREE.Mesh(
            new THREE.CylinderGeometry(0.01, 0.015, 0.05, 6),
            new THREE.MeshStandardMaterial({ color: 0xffe4c4, roughness: 0.6 })
        );
        figurine.position.set(3.9, 1.335, -0.55);
        scene.add(figurine);

        // Small box
        const trinketBox = new THREE.Mesh(
            new THREE.BoxGeometry(0.05, 0.03, 0.04),
            new THREE.MeshStandardMaterial({ color: 0x8b0000, roughness: 0.7 })
        );
        trinketBox.position.set(3.9, 1.325, -0.7);
        scene.add(trinketBox);

        // === COBWEBS IN CORNERS (subtle detail) ===
        const webMaterial = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            transparent: true,
            opacity: 0.15,
            side: THREE.DoubleSide
        });

        const createCobweb = () => {
            const group = new THREE.Group();
            // Simplified triangular web
            const webGeo = new THREE.BufferGeometry();
            const verts = new Float32Array([
                0, 0, 0,
                0.3, -0.15, 0,
                0, -0.3, 0
            ]);
            webGeo.setAttribute('position', new THREE.BufferAttribute(verts, 3));
            webGeo.computeVertexNormals();

            const web = new THREE.Mesh(webGeo, webMaterial);
            group.add(web);
            return group;
        };

        const web1 = createCobweb();
        web1.position.set(-3.95, 3.15, -3.95);
        scene.add(web1);

        const web2 = createCobweb();
        web2.position.set(3.95, 3.15, -3.95);
        web2.rotation.y = -Math.PI / 2;
        scene.add(web2);

        // === FALLEN LEAVES (scattered on floor for aged effect) ===
        const leafMaterial = new THREE.MeshStandardMaterial({
            color: 0x8b4513,
            roughness: 0.9,
            side: THREE.DoubleSide
        });

        for (let i = 0; i < 8; i++) {
            const leaf = new THREE.Mesh(
                new THREE.PlaneGeometry(0.03, 0.04),
                leafMaterial
            );
            leaf.position.set(
                (Math.random() - 0.5) * 6,
                0.005,
                (Math.random() - 0.5) * 6
            );
            leaf.rotation.x = -Math.PI / 2 + (Math.random() - 0.5) * 0.2;
            leaf.rotation.z = Math.random() * Math.PI * 2;
            scene.add(leaf);
        }

        // ============================================
        updateProgress(85, 'Setting up interaction system...');
        // INTERACTION SYSTEM
        // ============================================

        const raycaster = new THREE.Raycaster();
        raycaster.far = 4;
        const mouse = new THREE.Vector2(0, 0);
        let currentIntersected = null;

        function checkInteraction() {
            raycaster.setFromCamera(mouse, camera);
            const allMeshes = [];
            interactiveObjects.forEach(obj => {
                obj.traverse(child => {
                    if (child.isMesh) {
                        child.userData.parentGroup = obj;
                        allMeshes.push(child);
                    }
                });
            });

            const intersects = raycaster.intersectObjects(allMeshes);
            if (intersects.length > 0) {
                const obj = intersects[0].object.userData.parentGroup || intersects[0].object;
                if (obj.userData.type === 'interactive') {
                    currentIntersected = obj;
                    tooltip.textContent = obj.userData.tooltip;
                    tooltip.style.opacity = '1';
                    document.body.style.cursor = 'pointer';
                    return;
                }
            }
            currentIntersected = null;
            tooltip.style.opacity = '0';
            document.body.style.cursor = 'default';
        }

        document.addEventListener('click', () => {
            if (controls.isLocked && currentIntersected) {
                window.location.href = currentIntersected.userData.action;
            }
        });

        // ============================================
        // COLLISION DETECTION SYSTEM
        // ============================================

        const collisionBoxes = [
            // Format: { minX, maxX, minZ, maxZ } - AABB boxes for furniture
            // Bookshelf (against back-left wall)
            { minX: -3.95, maxX: -3.0, minZ: -3.5, maxZ: -1.5 },
            // Desk (against back-right wall)
            { minX: 1.8, maxX: 3.3, minZ: -3.5, maxZ: -2.3 },
            // Armchair
            { minX: -1.5, maxX: -0.5, minZ: 1.1, maxZ: 1.9 },
            // Side table
            { minX: -0.55, maxX: -0.05, minZ: 1.55, maxZ: 2.05 },
            // Grandfather clock
            { minX: -3.95, maxX: -3.35, minZ: -1.15, maxZ: -0.45 },
            // Typewriter table
            { minX: -3.9, maxX: -3.3, minZ: 0.95, maxZ: 1.45 },
            // Phone table
            { minX: 3.35, maxX: 3.85, minZ: -2.75, maxZ: -2.25 },
            // Floor globe
            { minX: 2.95, maxX: 3.45, minZ: 0.25, maxZ: 0.75 },
            // Floor lamp
            { minX: 2.6, maxX: 3.0, minZ: 1.3, maxZ: 1.7 },
            // Vintage camera on tripod
            { minX: 1.55, maxX: 2.05, minZ: -1.25, maxZ: -0.75 },
            // Suitcases near door
            { minX: 1.2, maxX: 1.8, minZ: 3.2, maxZ: 3.8 },
            // Wooden horse
            { minX: -3.35, maxX: -3.05, minZ: 3.35, maxZ: 3.65 },
            // Plants
            { minX: 3.1, maxX: 3.5, minZ: -3.55, maxZ: -3.05 },
            { minX: -3.75, maxX: -3.25, minZ: 2.25, maxZ: 2.75 },
        ];

        const playerRadius = 0.3; // Player collision radius

        function checkCollision(x, z) {
            for (const box of collisionBoxes) {
                // Expand the box by player radius for collision checking
                if (x > box.minX - playerRadius && x < box.maxX + playerRadius &&
                    z > box.minZ - playerRadius && z < box.maxZ + playerRadius) {
                    return true;
                }
            }
            return false;
        }

        // ============================================
        updateProgress(95, 'Starting animation...');
        // ANIMATION LOOP
        // ============================================

        let prevTime = performance.now();
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const delta = (time - prevTime) / 1000;
            const elapsed = clock.getElapsedTime();

            // Animate dust particles
            const positions = dustParticles.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i + 1] += Math.sin(elapsed + i) * 0.0003;
                positions[i] += Math.cos(elapsed * 0.5 + i) * 0.0002;

                // Wrap around
                if (positions[i + 1] > roomHeight) positions[i + 1] = 0;
                if (positions[i + 1] < 0) positions[i + 1] = roomHeight;
            }
            dustParticles.geometry.attributes.position.needsUpdate = true;

            // Animate grandfather clock pendulum
            if (grandfatherClock.userData.pendulum) {
                grandfatherClock.userData.pendulum.rotation.z = Math.sin(elapsed * 1.5) * 0.15;
            }

            if (controls.isLocked) {
                velocity.x -= velocity.x * 8.0 * delta;
                velocity.z -= velocity.z * 8.0 * delta;

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                if (moveForward || moveBackward) velocity.z -= direction.z * 12.0 * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * 12.0 * delta;

                // Store original position for collision resolution
                const prevX = camera.position.x;
                const prevZ = camera.position.z;

                // Apply movement
                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                // Room bounds
                const bounds = 3.4;
                camera.position.x = Math.max(-bounds, Math.min(bounds, camera.position.x));
                camera.position.z = Math.max(-bounds, Math.min(bounds, camera.position.z));

                // Collision detection - check X and Z separately for sliding behavior
                if (checkCollision(camera.position.x, camera.position.z)) {
                    // Try moving only in X
                    if (!checkCollision(camera.position.x, prevZ)) {
                        camera.position.z = prevZ;
                    }
                    // Try moving only in Z
                    else if (!checkCollision(prevX, camera.position.z)) {
                        camera.position.x = prevX;
                    }
                    // Neither works, revert both
                    else {
                        camera.position.x = prevX;
                        camera.position.z = prevZ;
                    }
                }

                checkInteraction();
            }

            prevTime = time;
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ============================================
        // INITIALIZE AND LOAD MODELS
        // ============================================

        // Store references to procedural objects for potential replacement
        const proceduralObjects = {
            bookshelf,
            desk,
            armchair,
            grandfatherClock,
            // floorLamp removed - included in armchair.glb
            sideTable,
            typewriter,
            radio,
            floorGlobe,
            telephone,
            mirror,
            suitcases
        };

        // Try to load and replace with GLTF models
        async function initModels() {
            console.log('🔍 Checking for 3D models in assets/models/...');
            await loadAllModels();

            // Replace procedural geometry with loaded models
            for (const [name, model] of Object.entries(loadedModels)) {
                if (model && proceduralObjects[name]) {
                    // Remove procedural version
                    scene.remove(proceduralObjects[name]);

                    // Add loaded model
                    scene.add(model);

                    // Copy userData for interactive objects
                    if (proceduralObjects[name].userData?.type === 'interactive') {
                        model.userData = { ...proceduralObjects[name].userData };
                        const idx = interactiveObjects.indexOf(proceduralObjects[name]);
                        if (idx !== -1) {
                            interactiveObjects[idx] = model;
                        }
                    }

                    console.log(`✓ Replaced ${name} with GLTF model`);
                }
            }

            // Handle gramophone specially (replaces nothing, just adds)
            if (loadedModels['gramophone']) {
                scene.add(loadedModels['gramophone']);
                console.log('✓ Added gramophone');
            }

            console.log(`📦 Loaded ${Object.keys(loadedModels).length} models`);
        }

        // Initialize
        initModels().then(() => {
            updateProgress(100, 'Ready!');
            setTimeout(() => {
                loading.style.opacity = '0';
                loading.style.transition = 'opacity 0.5s';
                setTimeout(() => loading.style.display = 'none', 500);
            }, 500);

            animate();
            console.log('Scene initialized successfully!');
        });
    </script>
</body>
</html>
